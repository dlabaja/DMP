\section{TypeScript}

TypeScript vznikl jako reakce na některé problémy s vývojem v JavaScriptu, primárně dynamickou kontrolu typů. Používá se pouze během vývoje a při bundlingu se transpiluje do JavaScriptu, aby ho prohlížeče dokázaly číst a spustit.

Již zmiňovanou výhodou a hlavním prodejním bodem je typová podpora. Výhodou dynamicky typovaného jazyka sice může být vyšší rychlost vývoje, ta ale (společně s~programem) padá, jakmile se nesprávný typ dostane do produkčního prostředí. Pokud to tak není podle použití zřejmé, musíte typ přímo definovat nebo použít \texttt{any}, které bude TypeScript ignorovat. Po spuštění pak staticky analyzuje celý kód a pokud najde chybu, odmítne ho sestavit.

S typy lze dělat mnoho operací. Spousta z nich je postavená na obecných typech, umožňujících bezpečně použít více než jeden typ.\cite{TSGenerics}. Například \texttt{Omit<Typ, Parametry>} umožňuje z typu odstranit určité parametry a pomocí \texttt{Pick} je zase přidat. \texttt{Partial<Typ>} zase narozdíl od \texttt{Required} všechny parametry udělá nepovinné, \texttt{Readonly} je nastaví jen pro čtení a \texttt{NonNullable} odstraní všechny hodnoty s \texttt{null} nebo \texttt{undefined} typem. S~typy lze dělat i logické operace, jako průnik nebo sjednocení.

S udržováním všech typů vám mohou pomoci interfacy, ve kterých můžete například definovat parametry pro funkce a metody a následně je (jako šablony) znovupoužít na dalších místech v projektu.

TypeScript přidává i rozšířenou podporu enumů, které umožňuje definovat sadu pojmenovaných konstant. Hodnota každé položky může být \texttt{number} nebo \texttt{string}.\cite{WhatIsAnEnum}

V neposlední řadě jazyk přidává nové funkce pro třídy. Nad metodami nyní můžete volat dekorátory modifikující jejich chování, nebo vytvořit nové se stejným jménem ale jinými argumenty a metodu takzvaně \enquote{přetížit}. Zatímco dekorátory mají prefix @, u~interních funkcí nutnost prefixu odpadá a nahrazuje ho klíčové slovo \texttt{private}. Pro ještě lepší zážitek z OOP lze používat abstraktní třídy, které nelze instancovat, ale jejichž implementaci mohou využít všichni její potomci.