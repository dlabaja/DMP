\subsection{Data, konvertory a API}
Postupně se dostávám výš a výš v naší frontendové hierarchii. Všechna data, která jsem dostával ve storu, jsou vlastně jen datové třídy. Konkrétně se jedná o třídy s definovanými poli reprezentujícími jejich obsah, gettery, a konstruktorem, jehož jediný parametr je interface se všemi dosaditelnými hodnotami, kterým třídu můžeme naplnit. Protože nemá settery, jde to jen jednorázově, a tak veškeré změny proměnných řeší až store a já zde nemusím používat MobX a @observable dekorátory.

Zhruba na stejné úrovni jako data mohou být i konvertory. Ne vždy jsou totiž data z databáze v pro nás ideálním formátu. Například čas i enumy jsou vyjádřené jako string, s čímž se ale špatně pracuje a museli bychom ho před každým použitím převést. Stejné je to i s různými objekty. Konverze probíhá ještě před tím, než se vše vloží do datové třídy, takže na stránce dostávám takovou strukturu dat, se kterou už můžu jednoduše pracovat. Přenos zpátky probíhá podobným způsobem, jen je třeba data zase převést na serverem podporovaný formát.

Ještě výš se nachází námi zpracované metody pro práci s API. Jsou systematicky rozdělené do několika tříd podle místa použití, abych, pokud potřebuji pracovat s nastavením, nemusel importovat něco, co má navíc funkce pro získání nejnovějších cest, přihlášení uživatele, a vrácení posledních hodnocení na Googlu. Každá metoda přijímá kromě dat také parametr na úpravu požadavku, díky kterému můžu měnit jeho hlavičku, cookie, nebo zda chci, aby při chybě stránka nespadla, a já si tak mohl vyjímku odchytit sám.

Každá z metod nakonec zavolá funkci importovanou z api.ts souboru. Tento soubor o délce přes čtyřicet tisíc řádků se automaticky generuje pomocí nástroje Swagger, a skrývá reálnou API implementaci, která je vlastně jen soubor všech možných HTTP požadavků, které fungují jako most mezi frontendem a backendem. Výš už pro mě cesta nevede.

Ve Storybooku je struktura trochu odlišná. API funkce se volají stále stejně, ale při načtení jakékoliv story se jejich původní implementace přepíší na mock. Ten vrací mock datové třídy, díky čemuž nejsou potřeba žádné konvertory. Abychom alespoň částečně simulovali internetovou odezvu, každá z metod vrací data až po uplynutí doby 300 milisekund.